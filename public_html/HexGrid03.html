<!DOCTYPE html>
<!--
To change this license header, choose License Headers in Project Properties.
To change this template file, choose Tools | Templates
and open the template in the editor.
-->
<html>
    <head>
        <title>HexGrid03</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script type="text/javascript" src="d3.js"></script>
        <script type="text/javascript" src="hexFunctions.js"></script>
        <script type="text/javascript" src="hexClasses.js"></script>
        <link rel="shortcut icon" href="favicon.ico">
        <style type="text/css">
            /* No style rules here yet */		
        </style>
    </head>
    <body>
        <h2> Hex Grid 3rd Pass: Tessellation & Rotation </h2> 
        <div id="grid">   </div>

        <script type="text/javascript">

            var svgW = 450;    //svg width
            var svgH = 450;    //svg height
            var originX = svgW / 2;
            var originY = svgH / 2;
            var i, j, k;
            var ss = Math.min(svgW, svgH) / 15;

            var tessHexObj = [];
            var tessHexData = [];

            var fourColors = ["#3366cc", "#dc3912", "#ff9900", "#109618"];
            var colorStep = [0, 1, 2, 3, 3, 2, 1, 0];

            // Draw only those vertices that are centers of hexagons
            // that tessallate the plane without overlap. These points
            // are generated by the vectors [2,1,0],[0,2,1],[1,0,2] with
            // positive factors in the same manner as the grid points
            // are represented by 3-dim hex coordinates

            var tessBound = 4;
            var cHexCoord = [];
            var colorParity = [];

            // Get the hex coordinates of all the centers of the tesselating
            // hexagons in a hexagonal bounded region.
            // These "hex" coordinates refer to 3 axes:
            // e1 = [1,0,0], e2 = [-0.5,h], e3 = [-0.5,-h]
            // these point at 3 vertices at angles 0, 2pi/3,4pi/3   
            k = 0;
            var alt = Math.sqrt(3);
            cHexCoord[0] = [0, 0, 0];
            k++;
            for (i = 1; i <= tessBound; i++) {
                for (j = 0; j <= tessBound; j++) {
                    cHexCoord[k] = [2 * i * ss, (i + (2 * j)) * ss, j * ss];
                    k++;
                    cHexCoord[k] = [j * ss, 2 * i * ss, (i + (2 * j)) * ss];
                    k++;
                    cHexCoord[k] = [(i + (2 * j)) * ss, j * ss, 2 * i * ss];
                    k++;
                }
            }

            var nbrTess = cHexCoord.length;
            var cRectTess = [];
            var cTessCoord = [];

            //Rectilinear coordinates for the centers of the tessellating hexes
            //Tess coordinates for the coloring
            for (k = 0; k < nbrTess; k++) {

                cRectTess[k] = hexToRect(cHexCoord[k]);
                cTessCoord[k] = rectToTess(cRectTess[k]);  // these are normalized

                let c1 = Math.abs(Math.round(cTessCoord[k][0] / ss));
                let c2 = Math.abs(Math.round(cTessCoord[k][1] / ss));
                let c3 = Math.abs(Math.round(cTessCoord[k][2] / ss));

                colorParity[k] = colorStep[(c1 % 2) + 2 * (c2 % 2) + 4 * (c3 % 2)];
                //console.log(k, c1, c2, c3, colorParity[k], fourColors[colorParity[k]]);

            }

            //Hexagon objects for the tess set and "points" data for D3 polygons
            //////////////////////////////////////////////////////////////////
            for (k = 0; k < nbrTess; k++) {
                tessHexObj[k] = new Hexagon(cRectTess[k][0], cRectTess[k][1], ss);
                tessHexData[k] = tessHexObj[k].hexagonPointsString();
                tessHexObj[k].key = k;
                tessHexObj[k].c = fourColors[colorParity[k]];
                //console.log(k, colorParity[k], fourColors[colorParity[k]], tessHexObj[k].key, tessHexObj[k].c);
            }

            var svgTessGrid = d3.select("#grid").append("svg")
                    .attr("width", svgW)
                    .attr("height", svgH)
                    .style("border", "1px solid black");

            var svgTessGroup = svgTessGrid.append("g")
                    .attr("transform", "translate(" + originX + "," + originY + ")");

            var tessHex = svgTessGroup.selectAll("polygon")
                    .data(tessHexData)
                    .enter()
                    .append("polygon")

                    .attr("points", function (d, i) {
                        return d;
                    })

                    .attr("stroke", "black")
                    .attr("fill", function (d, i) {
                        return gcolor(i);

                    })
                    .attr("stroke-width", 2);

            // The data to draw the 6 triangles inside the base hexagon
            var nTri = 0;
            var tessTriData = [];
            var tessTriObj = [];

            for (k = 0; k < nbrTess; k++) {
                for (j = 0; j < 6; j++) {
                    let pts = tessHexObj[k].trianglePointsArray(j);
                    let c = tessHexObj[k].c;
                    tessTriObj[nTri] = new Triangle(nTri, pts, c);
                    tessTriData[nTri] = tessHexObj[k].trianglePointsString(j);

                    nTri++;
                }
            }

            // Tesselation, now with triangles
            ///////////////////////////////////////////////////////////////////
            var svgTriGrid = d3.select("#grid").append("svg")
                    .attr("width", svgW)
                    .attr("height", svgH)
                    .style("border", "1px solid black");

            var svgTriGroup = svgTriGrid.append("g")
                    .attr("transform", "translate(" + originX + "," + originY + ")");

            var tessTri = svgTriGroup.selectAll("polygon")
                    .data(tessTriObj)
                    .enter()
                    .append("polygon")

                    .attr("points", function (d, i) {
                        //console.log(d.key,d.vCur,d.vCurString());
                        return d.vCurString();
                    })

                    .attr("stroke", "black")
                    .attr("fill", function (d, i) {
                        return d.c;
                    })

                    .attr("stroke-width", 1);

            //Hexagonal tessellation with 4-coloring
            ////////////////////////////////////////
            var svgTessGrid = d3.select("#grid").append("svg")
                    .attr("width", svgW)
                    .attr("height", svgH)
                    .style("border", "1px solid black");

            var svgTessGroup = svgTessGrid.append("g")
                    .attr("transform", "translate(" + originX + "," + originY + ")");

            var tessHex = svgTessGroup.selectAll("polygon")
                    .data(tessHexObj)               //Data is now the object
                    .enter()
                    .append("polygon")

                    .attr("points", function (d, i) {
                        return d.hexagonPointsString(); //Points retrieved from Data object  
                    })

                    .attr("stroke", "black")
                    .attr("fill", function (d, i) {
                        return d.c;
                    })
                    .attr("stroke-width", 2);
        </script>
    </body>
</html>
