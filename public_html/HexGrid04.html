<!DOCTYPE html>
<!--
To change this license header, choose License Headers in Project Properties.
To change this template file, choose Tools | Templates
and open the template in the editor.
-->
<html>
    <head>
        <title>HexGrid04</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script type="text/javascript" src="d3.js"></script>
        <script type="text/javascript" src="geometricFunctions.js"></script>
        <script type="text/javascript" src="hexClasses.js"></script>
        <link rel="shortcut icon" href="favicon.ico">
        <style type="text/css">
            /* No style rules here yet */		
        </style>
    </head>

    <body>
        <h2> Hex Grid 4th Pass: Tessellation & Rotation </h2> 
        <div id="grid">   </div>

        <script type="text/javascript">

            var svgW = 640;             //svg width
            var svgH = 640;             //svg height
            var originX = svgW / 2;
            var originY = svgH / 2;
            var i, j, k;
            var ss = Math.min(svgW, svgH) / 12; //side length of hexagons

            // Colors - index for gcolor
            var colix = [0, 1, 3, 4];

            //var fourColors = ["#3366cc", "#dc3912", "#ff9900", "#109618"];
            var fourColors = [gcolor(colix[0]), gcolor(colix[1]), gcolor(colix[2]), gcolor(colix[3])];

            // Determine the colors for Tess basis directions:
            // Origin has color 0 = fourColors[0]; 
            // e1 - alternates 1 and 0
            // e2 - 2 and 0
            // e3 - 3 and 0
            // this determines the entire coloring
            var colorStep = [0, 1, 2, 3, 3, 2, 1, 0];
            var colorParity = [];

            var tessBound = 2;          //Radial size of "board"
            var alt = Math.sqrt(3);     //2 x altitude

            var cHexCoord = [];
            var cTessCoord = [];
            var cRectCoord = [];

            var tessHexObj = [];
            var tessHexData = [];

            ///////////////////////////////////////////////////////////////////
            // Draw only those vertices that are centers of hexagons
            // that tessellate the plane without overlap. These points
            // are generated by the vectors [2,1,0],[0,2,1],[1,0,2] with
            // positive factors in the same manner as the grid points
            // are represented by 3-dim hex coordinates
            ///////////////////////////////////////////////////////////////////

            // Generate the hex coordinates
            k = 0;
            cHexCoord[0] = [0, 0, 0];
            k++;
            for (i = 1; i <= tessBound; i++) {
                for (j = 0; j <= tessBound; j++) {
                    cHexCoord[k] = [2 * i * ss, (i + (2 * j)) * ss, j * ss];
                    k++;
                    cHexCoord[k] = [j * ss, 2 * i * ss, (i + (2 * j)) * ss];
                    k++;
                    cHexCoord[k] = [(i + (2 * j)) * ss, j * ss, 2 * i * ss];
                    k++;
                }
            }

            var nbrHex = cHexCoord.length;

            //Rectilinear coordinates for the centers of the tessellating hexes
            //Tess coordinates for the coloring
            for (k = 0; k < nbrHex; k++) {
                cRectCoord[k] = hexToR(cHexCoord[k]);
                cTessCoord[k] = rToTess(cRectCoord[k]);  // these come normalized

                let c1 = Math.round(cTessCoord[k][0] / ss);
                let c2 = Math.round(cTessCoord[k][1] / ss);
                let c3 = Math.round(cTessCoord[k][2] / ss);

                colorParity[k] = colorStep[(c1 % 2) + 2 * (c2 % 2) + 4 * (c3 % 2)];
                //console.log(k, c1, c2, c3, colorParity[k], fourColors[colorParity[k]]);
            }

            ///////////////////////////////////////////////////////////////////
            //Hexagon objects for the tess set and "points" data for D3 polygons
            //////////////////////////////////////////////////////////////////
            for (k = 0; k < nbrHex; k++) {
                tessHexObj[k] = new Hexagon(cRectCoord[k][0], cRectCoord[k][1], ss);
                tessHexData[k] = tessHexObj[k].hexagonPointsString();
                tessHexObj[k].key = k;
                tessHexObj[k].c = fourColors[colorParity[k]];
                //console.log(k, colorParity[k], fourColors[colorParity[k]], tessHexObj[k].key, tessHexObj[k].c);
            }

            ////////////////////////////////////////////////////////////////////
            //Hexagonal tessellation with 4-coloring
            ///////////////////////////////////////////////////////////////////
            //
            var svgTessGrid = d3.select("#grid").append("svg")
                    .attr("width", svgW)
                    .attr("height", svgH)
                    .style("border", "1px solid black");

            var svgTessGroup = svgTessGrid.append("g")
                    .attr("transform", "translate(" + originX + "," + originY + ")");

            var tessHex = svgTessGroup.selectAll("polygon")
                    .data(tessHexObj)                   //Data is the array of Hexagon Objects
                    .enter()
                    .append("polygon")

                    .attr("points", function (d, i) {
                        return d.hexagonPointsString(); //Points retrieved from Data object  
                    })

                    .attr("stroke", "black")
                    .attr("fill", function (d, i) {
                        return d.c;
                    })
                    .attr("stroke-width", 2);

            for (k = 0; k < nbrHex; k++) {

                let c1 = Math.abs(Math.round(cTessCoord[k][0] / ss));
                let c2 = Math.abs(Math.round(cTessCoord[k][1] / ss));
                let c3 = Math.abs(Math.round(cTessCoord[k][2] / ss));

                colorParity[k] = ((c1 % 2) * colorStep[0] +
                        (c2 % 2) * colorStep[1] +
                        (c3 % 2) * colorStep[2]) % 4;
            }

            ///////////////////////////////////////////////////////////////////
            // The data to draw the 6 triangles inside the base hexagon
            var nTri = 0;
            var tessTriData = [];
            var tessTriObj = [];

            for (k = 0; k < nbrHex; k++) {
                for (j = 0; j < 6; j++) {
                    let pts = tessHexObj[k].trianglePointsArray(j);
                    let c = tessHexObj[k].c;
                    tessTriObj[nTri] = new Triangle(nTri, pts, c);
                    tessTriData[nTri] = tessHexObj[k].trianglePointsString(j);
                    nTri++;
                }
            }

            ///////////////////////////////////////////////////////////////////
            // Tesselation with triangles
            ///////////////////////////////////////////////////////////////////
            var svgTriGrid = d3.select("#grid").append("svg")
                    .attr("width", svgW)
                    .attr("height", svgH)
                    .style("border", "1px solid black");

            var svgTriGroup = svgTriGrid.append("g")
                    .attr("transform", "translate(" + originX + "," + originY + ")");

            var tessTri = svgTriGroup.selectAll("polygon")
                    .data(tessTriObj, function (d, i) {
                        return d.key;
                    })
                    .enter()
                    .append("polygon")

                    .attr("points", function (d, i) {
                        return d.vCurString();
                    })

                    .attr("stroke", "darkgray")
                    .attr("fill", function (d, i) {
                        return d.c;
                    })

                    .attr("stroke-width", 1)
                    //.on("mouseover", handleMouseOver)
                    //.on("mouseout", handleMouseOut)
                    .on("click", handleClick);

            function handleMouseOver(d, i) {
                // Use D3 to select element, change color and size
                d3.select(this)
                        .attr("fill", "magenta");
            }

            function handleMouseOut(d, i) {
                // Use D3 to select element, change color and size
                d3.select(this)
                        .attr("fill", function (d, i) {
                            return d.c;
                        });
            }
            //The hexagon with center closest to the click will
            //be rotated by pi/6
            function handleClick(d, i) {
                var i, k, j, k1;
                var nbrIx = [];
                var nbrIxSorted = [];
                var p = d3.mouse(this);
                var nearest = getNearestTriVertex(tessTriObj, p, ss);

                nbrIx = getTriNeighbors(tessTriObj, p, ss);
                if (nbrIx[0] < 0)
                    return;
                nbrIxSorted = sortTriByAngle(tessTriObj, nbrIx, [nearest.x, nearest.y]);

                //Initially set vNew = vCur for all triangles
                for (k = 0; k < nTri; k++) {
                    for (i = 0; i < 3; i++) {
                        tessTriObj[k].initCoord();
                    }
                }

                var nSL = nbrIxSorted.length;
                for (j = 0; j < nSL; j++) {
                    k = nbrIxSorted[j];
                    k1 = nbrIxSorted[(j + 1) % nSL];

                    for (i = 0; i < 3; i++) {
                        tessTriObj[k].vNew[i][0] = tessTriObj[k1].vCur[i][0];
                        tessTriObj[k].vNew[i][1] = tessTriObj[k1].vCur[i][1];
                    }
                }
                
                //Make common vertex of the 6 triangles stay fixed
                centerRotation(tessTriObj, nbrIxSorted, [nearest.x, nearest.y]);

                var tessTri2 = svgTriGroup.selectAll("polygon")
                        .data(tessTriObj, function (d, i) {
                            return d.key;
                        })
                        .transition()
                        .duration(1000)
                        .attr("points", function (d, i) {
                            return d.vNewString();
                        })
                        .attr("stroke", "darkgray")
                        .attr("fill", function (d, i) {
                            return d.c;
                        })
                        .attr("stroke-width", 1)
                        .on("end", function (d,i) {
                             //for (k = 0; k < nTri; k++) {
                              //tessTriObj[k].updateCoord();
                                //console.log(k,tessTriObj[k]);
                                    //
                             d.updateCoord();         
                            
                        });
            }
        </script>
    </body>
</html>
